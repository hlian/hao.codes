---
layout: post
title: "Functors, co- contra- and pro-"
author: hao
---

## Warning

The following blog post was hastily written to be a link to reference from a longer published piece where I ran out of space for a footnote. It assumes you have [read this wonderful article on positive and negative positions](https://www.schoolofhaskell.com/user/commercial/content/covariance-contravariance).

## Functors

I was told a functor in Haskell is any type with kind `* -> *` that admits an instance for the class

~~~haskell
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
~~~

I am here to tell you that _this is a lie_. Or, well, not a lie but at least a slightly myopic way of thinking about things.

I like to think about functors like this: any type parametrized on `a` where `a` only appears in a _non-negative position_ admits is a functor on the type `a`. This sounds like nonsense, but take as an example this type:

~~~haskell
newtype FromInt = FromInt (Int -> a)
~~~

This type easily admits a `Functor` instance: given an `a -> b`, we simply compose it onto our `Int -> a` to get an `Int -> b`. A more complicated example:

~~~haskell
data [a] = [] | a:[a]
~~~

It turns out that `a` never appears in a negative position here, but it is hard to see because we have obfuscated the actual type with Haskell's lovely ADT syntax. We can convert this to its equivalent type:

~~~haskell
newtype List a = List (forall r. r -> (a -> List a -> r) -> r)
~~~

To implement the `Functor` instance: given an `a -> b`, we destructure the list. In the nil case we have no work to do; in the cons case we apply our function and recurse:

~~~haskell
instance Functor List where
  fmap a2b (List alist) =
    List (\nil cons -> alist nil (\a as -> cons (a2b a) (fmap a2b as)))
~~~

Take a moment to convince yourself that this works _precisely because `a` never appears in the negative position_. We can illustrate this point better by looking at a type where this rule is violated:

## Contravariant functors

~~~
newtype Predicate a = Predicate (a -> Bool)
~~~

Given an `a -> b` ... there is not much we can do. As a matter of fact, because `a` never appears in a positive position we can in fact implement an instance of `Contravariant`:

~~~haskell
class Contravariant f where
  contramap :: (a -> b) -> (f b -> f a)

instance Contravariant Predicate where
  contramap a2b (Predicate b2bool) = Predicate (b2bool . a2b)
~~~

We can call this new type of functor a "contravariant" functor and realize that the functor we were talking all along above was a "covariant" functor. Just names to distinguish between the never-positive/never-negative rules.

Another example:

~~~haskell
newtype Const constant a = Const constant

instance Contravariant Const where
  contramap _ (Const c) = Const c

instance Functor Const where
  fmap _ (Const c) = Const c
~~~

Because `a` appeared in neither a positive nor negative position (it is nonvariant) we were able to demonstrate it to admit covariant and contravariant functors.

Knowing this, this type takes on a charged meaning:

~~~haskell
type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s
~~~

What can we say about `f` in this type? And what will it probably usually be?

## Profunctors

What about types parametrized over both covariant variable and contravariant variables? They could admit both a `Functor` and a `Contravariant` (if we allow the order of their variables to be reordered in the declaration) but it would be much more useful to do _both at the same time_. And for that we have

~~~haskell
class Profunctor p where
  dimap :: (contra' -> contra) -> (co -> co') -> p co contra -> p co' contra'
~~~

The typeclass of `* -> * -> *` types where the first star never appears in a negative position and the second star never appears in a positive position. Examples include:

~~~haskell
-- a negative
-- b positive
newtype (->) a b = a -> b

instance Profunctor (->) where
  dimap s2a b2t a2b =
    b2t . a2b . s2a

-- a negative
-- b positive (if m is a covariant functor)
newtype Kleisli m a b = Kleisli (a -> m b)

instance Monad m => Profunctor (Kleisli m) where
  dimap s2a b2t (Kleisli a2mb) =
    Kleisli (fmap b2t . a2mb . s2a)
~~~

Why do this, except for the sake of abstraction? Well, it turns out that profunctors are eminently composable. See for example [Data.Profunctor.Composition](https://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Composition.html), which we will summarize here:

~~~haskell
-- not real haskell
-- sorry i'm a naughty baby

data (⊗) f g contra co = forall x. (f contra x) ⊗ (g x co)

instance (Profunctor f, Profunctor g) => Profunctor (f ⊗ g) where
  dimap contra co (f ⊗ g) = (dimap contra id f) ⊗ (dimap id co g)
~~~

The gist of this weird operator is that profunctors _compose_, much in the same way that `.` composes functions. It is this idea that underlies the `lens` package and explains why optics compose so easily: every optic is a profunctor.

* `Iso`s (isomorphisms) universally quantify over the profunctor (`type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)`); most other optics, like `Lens` or `Prism`,  assume the profunctor to be `(->)`. When you compose an `Iso` and a `Lens`, the type checker unifies the profunctor to be `(->)`. As a result you get a `Lens` – so the lowest common denominator between an iso and a lens is a lens, as expected.

* `Len`s constrains the `f` to be `Functor`, `Getter`s constrains the `f` to both `Contravariant` and `Functor`. When composed, the type checker picks up both the `Contravariant` and the `Functor` constraints – so the lowest common denominator between a lens and a getter is a getter, as expecte.d

* `Len`s assumes `(->)` to be the profunctor and universally quantifies over `f` as a `Functor`. `Prism` constrains the `f` to be `Applicative`. When composed, we get `(->)` as the profunctor and `f` to be `Applicative` – a traversal!

We will see this again when we try to unpack Phil Freeman's excellent ["Fun with Profunctors"](https://www.youtube.com/watch?v=OJtGECfksds) talk, but this orphaned free-floating footnote, which nobody asked for and nobody will ask for, will have to do for now.
