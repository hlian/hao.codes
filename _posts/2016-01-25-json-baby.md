---
layout: post
title: "Using JSON files as if they were Haskell values"
author: hao
---

life life maximally with simple language semantics

## JSONBaby.hs

```haskell
#!/usr/bin/env stack
-- stack --resolver lts-4.2 --install-ghc runghc --package file-embed --package aeson --package lens --package lens-aeson

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module JSONBaby where

import Control.Lens
import Data.Aeson
import Data.Aeson.Lens
import Data.FileEmbed

value :: Maybe Value
value = (decode . view lazy) $(embedFile "a.json")

main :: IO ()
main = do
  print value
  print (value ^? _Just . key "hello")
  print (value ^? _Just . key "this" . key "can" . key "be")
```

This is a recursive datatype, so writing a fold comes pretty natural:

```haskell
import Data.Foldable (toList)

count (Object hashmap) = sum (map count (toList hashmap))
count (Array vector)   = sum (map count (toList vector))
count (Number sci)     = sci
count _                = 0
```

## a.json

```json
{
    "hello": "world",
    "this": {
        "can": {
            "be": "nested"
        }
    }
}
```

## output

```haskell
Just (Object (fromList [("hello",String "world"),("this",Object (fromList [("can",Object (fromList [("be",String "nested")]))]))]))
Just (String "world")
Just (String "nested")
```
